import os
import json
import logging
from promptflow.client import PFClient, load_flow
from fts_commons.utils.util import generate_unique_number, get_strategy_storage_path, flatten_config
from fts_commons.utils.objects import TaskStatusEnum, TriggerResponse, EvalConfig, EvalStaticConfig, EvaluationRuntimeConfig
from common_svc.config.config_store import BlobConfig
from common_svc.storage.blob_client import setup_blob_resource
from fts_mgmt.utils.db_checks import validate_task

logger = logging.getLogger(__name__)

class TaskMgmtService:
    def __init__(self, userModel: UserModel):
        self.user_model = userModel
        self.task_mgmt_dao = TaskMgmtDao()
        self.data_mgmt_service_dao = DataMgmtServiceDao()
        self.es_service_daos_service_dao = EvaluationStrategyDAO()
        self.blob_service = BlobService()
        self.user_json = [{"id": self.user_model.userId, "name": f"{self.user_model.firstName} {self.user_model.lastName}"}]

    async def trigger_task(self, Task_type_enum: TaskTypeEnum, trigger_config):
        task_id = generate_unique_number()

        # Validate incoming config
        trigger_config.validate_task_runtime_config(task_type=Task_type_enum)
        validate_task(trigger_config=trigger_config, task_type=Task_type_enum)

        strategy_id = trigger_config.strategyId
        dataset_id = trigger_config.datasetId
        project_id = trigger_config.projectId

        # Step 1: Save initial task to DB
        self.task_mgmt_dao.create_task(
            task_id=task_id,
            task_type=Task_type_enum,
            config=trigger_config.dict(by_alias=True, exclude_none=True),
            status=TaskStatusEnum.IN_PROGRESS,
            created_by=self.user_json,
            project_id=project_id
        )

        try:
            # Step 2: Load strategy config
            strategy_data = self.es_service_daos_service_dao.get_evaluation_strategy_by_id(strategy_id=strategy_id)
            config_wrapper = strategy_data.config

            if isinstance(config_wrapper, str):
                config_wrapper = json.loads(config_wrapper)

            config_raw = config_wrapper.get("config", config_wrapper)
            strategy_static = config_raw.get("static", {})
            strategy_dynamic = config_raw.get("dynamic", {})

            logger.info(f"Strategy static: {strategy_static}")
            logger.info(f"Strategy dynamic: {strategy_dynamic}")

            if not strategy_static or not strategy_dynamic:
                raise Exception("Missing 'static' or 'dynamic' in strategy config")
            if "evalRunTimeParams" not in strategy_dynamic:
                raise Exception("Missing 'evalRunTimeParams' in strategy dynamic config")

            # Step 3: Merge runtime config, skipping empty strings
            runtime_config = trigger_config.taskRuntimeConfig.dict(by_alias=True, exclude_none=True)
            cleaned_runtime_config = {
                k: v for k, v in runtime_config.items()
                if not (isinstance(v, str) and v.strip() == "")
            }
            merged_dynamic = {**strategy_dynamic, **cleaned_runtime_config}

            eval_config = EvalConfig(
                static=EvalStaticConfig(**strategy_static),
                dynamic=EvaluationRuntimeConfig(**merged_dynamic)
            )

            # Step 4: Flatten config for Promptflow
            updated_config = eval_config.dict()
            logger.info(f"Updated config: {updated_config}")
            flattened_config = flatten_config(updated_config)
            logger.info(f"Flattened config: {flattened_config}")

            # Step 5: Load Promptflow
            strategy_path = get_strategy_storage_path(strategy_id=strategy_id, strategy_name=strategy_data.name)
            absolute_path = self.blob_service.blob_location(
                container_name=BlobConfig().BLOB_DOC_CONTAINER,
                absolute_path=strategy_path
            )

            local_path = os.path.join(os.getcwd(), "promptflow")
            os.makedirs(local_path, exist_ok=True)
            setup_blob_resource().copy_blob_dir_to_local(absolute_path, os.path.dirname(local_path))

            pf_client = PFClient()
            pf_flow = load_flow(source=local_path)
            flow_result = pf_flow.invoke(inputs=flattened_config)
            results = flow_result.output

            # Step 6: Mark task success
            self.task_mgmt_dao.update_task(
                task_id=task_id,
                status=TaskStatusEnum.SUCCESS,
                output={"outputDirectory": flattened_config.get("dynamic_evalRunTimeParams_csv_path")}
            )

            task = self.task_mgmt_dao.get_task_by_id(task_id=task_id)

            return TriggerResponse(
                taskId=task.id,
                taskType=Task_type_enum,
                taskStatus=task.status,
                createdBy=task.created_by,
                createdTs=task.created_ts,
                modifiedBy=task.modified_by,
                modifiedTs=task.modified_ts
            )

        except Exception as e:
            error_msg = f"Evaluation task failed for Task ID {task_id}: {str(e)}"
            logger.error(error_msg, exc_info=True)
            self.task_mgmt_dao.update_task(
                task_id=task_id,
                status=TaskStatusEnum.FAILURE,
                output={"error": error_msg}
            )
            raise Exception(error_msg)











# Step 4: Merge trigger input runtime config with strategy config
runtime_config = trigger_config.taskRuntimeConfig

# Remove keys from runtime_config that are explicitly empty strings
rc_dict = runtime_config.dict(exclude_none=True, by_alias=True)

# This removes keys like {"csv_path": ""}, if present
cleaned_rc_dict = {
    k: v for k, v in rc_dict.items()
    if not (isinstance(v, str) and v.strip() == "")
}

# Merge cleaned runtime config into original strategy config
updated_dynamic_config = {
    **eval_config.dynamic.dict(),
    **cleaned_rc_dict
}

# Rebuild final dynamic config
eval_config.dynamic = EvaluationRuntimeConfig(**updated_dynamic_config)






def flatten_config(config: dict, parent_key: str = '', sep: str = '_') -> dict:
    """
    Flattens nested dictionary except for *_kwargs which are kept as full objects.
    """
    flattened = {}
    for k, v in config.items():
        new_key = f"{parent_key}{sep}{k}" if parent_key else k
        if isinstance(v, dict):
            # Do NOT flatten kwargs dicts â€” keep them as whole objects
            if k.endswith("_kwargs"):
                flattened[new_key] = v
            else:
                flattened.update(flatten_config(v, new_key, sep=sep))
        else:
            flattened[new_key] = v
    return flattened
