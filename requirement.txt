import matplotlib.pyplot as plt
import numpy as np

# Raw data
volumes = ['30K', '50L', '1L']
factual = [30, 40, 80]
conceptual = [40, 50, 75]
procedural = [0, 50, 80]
reasoning = [0, 0, 80]
inferential = [0, 0, 82]
accuracy = [70, 80, 90]  # Sample accuracy values corresponding to volumes

# Combine into array and normalize each column to sum to 100%
data = np.array([factual, conceptual, procedural, reasoning, inferential])
column_sums = data.sum(axis=0)
normalized_data = (data / column_sums) * 100

# Bar positions
x = np.arange(len(volumes))

# Create figure and axis
fig, ax1 = plt.subplots(figsize=(10, 6))

# Stacked bar chart
bottom = np.zeros(len(volumes))
colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd']
labels = ['Factual', 'Conceptual', 'Procedural', 'Reasoning', 'Inferential']

for i in range(len(normalized_data)):
    bars = ax1.bar(x, normalized_data[i], bottom=bottom, label=labels[i], color=colors[i])
    for j, bar in enumerate(bars):
        if normalized_data[i][j] > 3:
            ax1.text(
                bar.get_x() + bar.get_width() / 2,
                bottom[j] + normalized_data[i][j] / 2,
                f'{normalized_data[i][j]:.0f}%',
                ha='center',
                va='center',
                fontsize=8,
                color='white'
            )
    bottom += normalized_data[i]

ax1.set_xlabel('Data Volume')
ax1.set_ylabel('Question Type Distribution (%)')
ax1.set_xticks(x)
ax1.set_xticklabels(volumes)
ax1.set_ylim(0, 100)
ax1.legend(loc='upper left')
ax1.grid(axis='y', linestyle='--', alpha=0.6)

# Accuracy line chart using secondary Y-axis
ax2 = ax1.twinx()
ax2.plot(x, accuracy, color='black', marker='o', linewidth=2, label='Accuracy (%)')
ax2.set_ylabel('Accuracy (%)', color='black')
ax2.set_ylim(0, 100)
for i, acc in enumerate(accuracy):
    ax2.text(x[i], acc + 2, f'{acc}%', ha='center', color='black', fontsize=9)

# Combine legends from both axes
lines, labels = ax1.get_legend_handles_labels()
lines2, labels2 = ax2.get_legend_handles_labels()
ax1.legend(lines + lines2, labels + labels2, loc='upper center')

plt.title('Normalized Question Type Distribution with Accuracy')
plt.tight_layout()

# Save figure
final_chart_path = "/mnt/data/question_distribution_with_accuracy.png"
plt.savefig(final_chart_path)
final_chart_path






output_path = flattened_config.get("dynamic.evalRunTimeParams.blob_path")
self.task_mgmt_dao.update_task(
    task_id=task_id,
    status=TaskStatusEnum.SUCCESS,
    output={"outputDirectory": output_path}
)






import os
import glob

@tool
def compute_scores_for_df(
    csv_path: str,
    output_path: str,
    llm_as_judge_prompt: str,
    rai_model_name: str,
    rai_wrapper_name: str,
    llm_as_judge_gen_model_kwargs: dict,
    qstn_col="Question",
    col_generated_ans="finetuned_response",
    gndth_col="Answer"
) -> str:
    """
    Auto-detect CSV from promptflow folder if path is missing.
    """

    # Step 1: If no csv_path given, look in ./promptflow folder
    if not csv_path or csv_path.strip() == "":
        base_path = os.getcwd()
        promptflow_path = os.path.join(base_path, "promptflow")

        print(f"[INFO] No CSV path provided. Looking for CSV in: {promptflow_path}")

        csv_files = glob.glob(os.path.join(promptflow_path, "*.csv"))
        if not csv_files:
            raise FileNotFoundError("No CSV file found in ./promptflow folder.")

        csv_path = csv_files[0]
        print(f"[INFO] Auto-detected CSV file: {csv_path}")

    # Step 2: Load CSV and run evaluation
    df_results = pd.read_csv(csv_path)
    ...

