# evaluation_strategy_mgmt_api.py
from fastapi import APIRouter, Depends, UploadFile, File, Form, Query, Response
from common_svc.logger.log_util import configure_loggers
from fts_commons.schema.user_model import UserModel
from fts_commons.utils.authorization_service import get_login_info
from fts_commons.utils.util import JsonResponse
from fts_mgmt.services.evaluation_strategy_service import EvaluationStrategyService
from fts_mgmt.utils.errors import Errors
import csv
import io

logger = configure_loggers()
eval_api = APIRouter(tags=["Evaluation Strategy Management"])

@eval_api.post("")
async def create_evaluation_strategy(
    name: str = Form(...),
    description: str = Form(None),
    strategyFile: UploadFile = File(...),
    userModel: UserModel = Depends(get_login_info)
):
    json_response = JsonResponse()
    try:
        result = await EvaluationStrategyService(userModel).create_evaluation_strategy(name, description, strategyFile)
        json_response.success = True
        json_response.result = result
    except Exception as e:
        error = Errors.E401.format(e=str(e))
        json_response.error = error
        logger.error(error, exc_info=True)
    return json_response.dict()

@eval_api.patch("/{strategy_id}")
async def update_evaluation_strategy(
    strategy_id: str,
    name: str = Form(None),
    description: str = Form(None),
    strategyFile: UploadFile = File(None),
    userModel: UserModel = Depends(get_login_info)
):
    json_response = JsonResponse()
    try:
        result = await EvaluationStrategyService(userModel).update_evaluation_strategy(strategy_id, name, description, strategyFile)
        json_response.success = True
        json_response.result = result
    except Exception as e:
        error = Errors.E405.format(e=str(e))
        json_response.error = error
        logger.error(error, exc_info=True)
    return json_response.dict()

@eval_api.get("/{strategy_id}")
async def get_evaluation_strategy(strategy_id: str, userModel: UserModel = Depends(get_login_info)):
    json_response = JsonResponse()
    try:
        result = await EvaluationStrategyService(userModel).get_evaluation_strategy_by_id(strategy_id)
        json_response.success = True
        json_response.result = result
    except Exception as e:
        error = Errors.E402.format(e=str(e))
        json_response.error = error
        logger.error(error, exc_info=True)
    return json_response.dict()

@eval_api.get("")
async def get_all_evaluation_strategies(
    limit: int = Query(10, description="Limit the number of results"),
    offset: int = Query(0, description="Offset for pagination"),
    userModel: UserModel = Depends(get_login_info)
):
    json_response = JsonResponse()
    try:
        result = await EvaluationStrategyService(userModel).get_all_evaluation_strategies(limit, offset)
        json_response.success = True
        json_response.result = result
    except Exception as e:
        error = Errors.E404.format(e=str(e))
        json_response.error = error
        logger.error(error, exc_info=True)
    return json_response.dict()

@eval_api.delete("/{strategy_id}")
async def delete_evaluation_strategy(strategy_id: str, userModel: UserModel = Depends(get_login_info)):
    json_response = JsonResponse()
    try:
        result = await EvaluationStrategyService(userModel).delete_evaluation_strategy(strategy_id)
        json_response.success = True
        json_response.result = result
    except Exception as e:
        error = Errors.E403.format(e=str(e))
        json_response.error = error
        logger.error(error, exc_info=True)
    return json_response.dict()

@eval_api.get("/{strategy_id}/download")
async def download_evaluation_strategy(strategy_id: str, userModel: UserModel = Depends(get_login_info)):
    try:
        rows = await EvaluationStrategyService(userModel).download_evaluation_strategy(strategy_id)
        if not rows:
            raise Exception("No strategy data available for download.")

        output = io.StringIO()
        writer = csv.DictWriter(output, fieldnames=rows[0].keys())
        writer.writeheader()
        writer.writerows(rows)

        return Response(
            content=output.getvalue(),
            media_type="text/csv",
            headers={"Content-Disposition": f"attachment; filename={strategy_id}.csv"}
        )
    except Exception as e:
        logger.error(f"Error downloading strategy {strategy_id}: {e}", exc_info=True)
        raise


# evaluation_strategy_service.py
import io
import csv
import logging
from fastapi import UploadFile
from fts_commons.schema.user_model import UserModel
from fts_commons.utils.objects import EvaluationStrategyResponse
from fts_commons.utils.util import generate_unique_number
from fts_mgmt.dao.evaluation_strategy_dao import EvaluationStrategyDAO

logger = logging.getLogger(__name__)

class EvaluationStrategyService:
    def __init__(self, user_model: UserModel):
        self.user_model = user_model
        self.dao = EvaluationStrategyDAO()

    async def create_evaluation_strategy(self, name: str, description: str, strategyFile: UploadFile):
        try:
            strategy_id = generate_unique_number()
            content = await strategyFile.read()
            decoded_content = content.decode('utf-8').splitlines()
            reader = csv.DictReader(decoded_content)
            strategy_rows = [row for row in reader]

            if not strategy_rows:
                raise Exception("CSV file is empty or invalid.")

            self.dao.save_evaluation_strategy(strategy_id, name, description, strategy_rows, self.user_model.userId)
            return await self.get_evaluation_strategy_by_id(strategy_id)

        except Exception as e:
            logger.error(f"Error creating evaluation strategy: {e}", exc_info=True)
            raise Exception(str(e))

    async def update_evaluation_strategy(self, strategy_id: str, name: str, description: str, strategyFile: UploadFile):
        try:
            strategy_rows = None
            if strategyFile:
                content = await strategyFile.read()
                decoded_content = content.decode('utf-8').splitlines()
                reader = csv.DictReader(decoded_content)
                strategy_rows = [row for row in reader]

            self.dao.update_evaluation_strategy(strategy_id, name, description, strategy_rows, self.user_model.userId)
            return await self.get_evaluation_strategy_by_id(strategy_id)

        except Exception as e:
            logger.error(f"Error updating evaluation strategy: {e}", exc_info=True)
            raise Exception(str(e))

    async def get_evaluation_strategy_by_id(self, strategy_id: str):
        try:
            saved = self.dao.get_evaluation_strategy_by_id(strategy_id)
            return EvaluationStrategyResponse(
                id=saved.id,
                name=saved.name,
                description=saved.description,
                config=saved.config,
                created_by=saved.created_by,
                modified_by=saved.modified_by,
                created_ts=saved.created_ts,
                modified_ts=saved.modified_ts
            )
        except Exception as e:
            logger.error(f"Error fetching evaluation strategy: {e}", exc_info=True)
            raise Exception(str(e))

    async def get_all_evaluation_strategies(self, limit: int, offset: int):
        try:
            strategies, count = self.dao.get_all_evaluation_strategies(limit, offset)
            items = [
                EvaluationStrategyResponse(
                    id=s.id,
                    name=s.name,
                    description=s.description,
                    config=s.config,
                    created_by=s.created_by,
                    modified_by=s.modified_by,
                    created_ts=s.created_ts,
                    modified_ts=s.modified_ts
                ) for s in strategies
            ]
            return {"items": items, "count": count, "limit": limit, "offset": offset}
        except Exception as e:
            logger.error(f"Error listing evaluation strategies: {e}", exc_info=True)
            raise Exception(str(e))

    async def delete_evaluation_strategy(self, strategy_id: str):
        try:
            self.dao.delete_evaluation_strategy(strategy_id)
            return {"message": f"Evaluation Strategy {strategy_id} deleted successfully."}
        except Exception as e:
            logger.error(f"Error deleting evaluation strategy: {e}", exc_info=True)
            raise Exception(str(e))

    async def download_evaluation_strategy(self, strategy_id: str):
        try:
            strategy = self.dao.get_evaluation_strategy_by_id(strategy_id)
            return strategy.config if strategy else []
        except Exception as e:
            logger.error(f"Error retrieving config for download: {e}", exc_info=True)
            raise


# evaluation_strategy_dao.py
import logging
from common_svc.db.base import DBSession
from fts_commons.db.model import EvaluationStrategies
from fts_commons.utils.util import get_current_datetime

logger = logging.getLogger(__name__)

class EvaluationStrategyDAO:
    def __init__(self):
        self.now = get_current_datetime()

    def save_evaluation_strategy(self, id, name, description, config, created_by):
        try:
            with DBSession() as db:
                strategy = EvaluationStrategies(
                    id=id,
                    name=name,
                    description=description,
                    config=config,
                    created_by=created_by,
                    modified_by=created_by,
                    created_ts=self.now,
                    modified_ts=self.now
                )
                db.session.add(strategy)
        except Exception as e:
            logger.error(f"Failed to save strategy: {e}")
            raise

    def update_evaluation_strategy(self, strategy_id, name, description, config, modified_by):
        try:
            with DBSession() as db:
                update_data = {}
                if name:
                    update_data['name'] = name
                if description:
                    update_data['description'] = description
                if config:
                    update_data['config'] = config
                if modified_by:
                    update_data['modified_by'] = modified_by
                update_data['modified_ts'] = self.now

                updated = db.session.query(EvaluationStrategies).filter(
                    EvaluationStrategies.id == strategy_id
                ).update(update_data)
                if not updated:
                    raise Exception(f"Evaluation Strategy {strategy_id} not found.")
        except Exception as e:
            logger.error(f"Error updating strategy: {e}")
            raise

    def get_evaluation_strategy_by_id(self, strategy_id):
        try:
            with DBSession() as db:
                return db.session.query(EvaluationStrategies).filter(
                    EvaluationStrategies.id == strategy_id
                ).first()
        except Exception as e:
            logger.error(f"Error fetching strategy by ID: {e}")
            raise

    def get_all_evaluation_strategies(self, limit: int, offset: int):
        try:
            with DBSession() as db:
                query = db.session.query(EvaluationStrategies)
                total = query.count()
                records = query.offset(offset).limit(limit).all()
                return records, total
        except Exception as e:
            logger.error(f"Error listing strategies: {e}")
            raise

    def delete_evaluation_strategy(self, strategy_id):
        try:
            with DBSession() as db:
                deleted = db.session.query(EvaluationStrategies).filter(
                    EvaluationStrategies.id == strategy_id
                ).delete()
                if not deleted:
                    raise Exception(f"Evaluation Strategy {strategy_id} not found.")
        except Exception as e:
            logger.error(f"Error deleting strategy: {e}")
            raise

