# evaluation_strategy_mgmt_api.py
import logging
from io import BytesIO
from zipfile import ZipFile
from fastapi import APIRouter, Depends, UploadFile, File, Form, Response, HTTPException, Query
from common_svc.logger.log_util import configure_loggers
from fts_commons.schema.user_model import UserModel
from fts_commons.utils.authorization_service import get_login_info
from fts_commons.utils.util import JsonResponse
from evaluation_strategy.services.evaluation_strategy_mgmt_service import EvaluationStrategyService
from evaluation_strategy.utils.errors import Errors

logger = logging.getLogger(__name__)
configure_loggers()

es_apis = APIRouter(tags=["Evaluation Strategies Management APIS"])

@es_apis.post("/evaluation-strategy")
async def create_evaluation_strategy(
    name: str = Form(...),
    description: str = Form(None),
    strategyFile: UploadFile = File(...),
    userModel: UserModel = Depends(get_login_info)
):
    json_response = JsonResponse()
    try:
        result = await EvaluationStrategyService(userModel).create_evaluation_strategy(name, description, strategyFile)
        json_response.success = True
        json_response.result = result
    except Exception as e:
        error = Errors.E401.format(e=str(e))
        json_response.error = error
        logger.error(error, exc_info=True)
    return json_response.dict()

@es_apis.patch("/evaluation-strategy/{esId}")
async def update_evaluation_strategy(
    esId: str,
    name: str = Form(None),
    description: str = Form(None),
    strategyFile: UploadFile = File(...),
    userModel: UserModel = Depends(get_login_info)
):
    json_response = JsonResponse()
    try:
        result = await EvaluationStrategyService(userModel).update_evaluation_strategy(esId, name, description, strategyFile)
        json_response.success = True
        json_response.result = result
    except Exception as e:
        error = Errors.E402.format(e=str(e), esId=esId)
        json_response.error = error
        logger.error(error, exc_info=True)
    return json_response.dict()

@es_apis.get("/evaluation-strategy/{esId}")
async def get_evaluation_strategy_by_id(esId: str, userModel: UserModel = Depends(get_login_info)):
    json_response = JsonResponse()
    try:
        data = await EvaluationStrategyService(userModel).get_evaluation_strategy_by_id(esId)
        json_response.success = True
        json_response.result = data
    except Exception as e:
        error = Errors.E403.format(e=str(e), esId=esId)
        json_response.error = error
        logger.error(error, exc_info=True)
    return json_response.dict()

@es_apis.get("/evaluation-strategy")
async def get_all_evaluation_strategies(
    limit: int = Query(10),
    offset: int = Query(0),
    userModel: UserModel = Depends(get_login_info)
):
    json_response = JsonResponse()
    try:
        data = await EvaluationStrategyService(userModel).get_all_evaluation_strategies(limit, offset)
        json_response.success = True
        json_response.result = data
    except Exception as e:
        error = Errors.E404.format(e=str(e))
        json_response.error = error
        logger.error(error, exc_info=True)
    return json_response.dict()

@es_apis.delete("/evaluation-strategy/{esId}")
async def delete_evaluation_strategy(esId: str, userModel: UserModel = Depends(get_login_info)):
    json_response = JsonResponse()
    try:
        result = await EvaluationStrategyService(userModel).delete_evaluation_strategy(esId)
        json_response.success = True
        json_response.result = result
    except Exception as e:
        error = Errors.E405.format(e=str(e), esId=esId)
        json_response.error = error
        logger.error(error, exc_info=True)
    return json_response.dict()

@es_apis.get("/evaluation-strategy/{esId}/download")
async def download_evaluation_strategy(esId: str, userModel: UserModel = Depends(get_login_info)):
    try:
        files, filenames = await EvaluationStrategyService(userModel).download_evaluation_strategy(esId)
        if not any(files):
            raise HTTPException(status_code=404, detail="No files found or empty dataset")

        zipBuffer = BytesIO()
        with ZipFile(zipBuffer, "w") as zipFile:
            for content, filename in zip(files, filenames):
                if content:
                    zipFile.writestr(filename, content)

        return Response(
            content=zipBuffer.getvalue(),
            media_type="application/zip",
            headers={"Content-Disposition": f'attachment; filename="{esId}.zip"'}
        )
    except Exception as e:
        error = Errors.E406.format(e=str(e), esId=esId)
        logger.error(error, exc_info=True)
        return JsonResponse(success=False, error=error).dict()


# evaluation_strategy_mgmt_service.py
import logging
import os
import json
import zipfile
import io
from fastapi import UploadFile
from common_svc.logger.log_util import configure_loggers
from common_svc.config.config_store import BlobConfig
from common_svc.storage.storage_config import BlobLocation
from common_svc.storage.blob_service import BlobService
from fts_commons.utils.util import generate_unique_number, get_strategy_storage_path
from fts_commons.schema.user_model import UserModel
from fts_commons.utils.objects import EvaluationResponse, EvalConfig
from evaluation_strategy.dao.evaluation_strategy_mgmt_dao import EvaluationStrategyDAO
from evaluation_strategy.utils.constants import ALLOWED_COMPRESSIONS

configure_loggers()
logger = logging.getLogger(__name__)

class EvaluationStrategyService:
    def __init__(self, user_model: UserModel):
        self.user_model = user_model
        self.evaluation_dao = EvaluationStrategyDAO()
        self.blob_service = BlobService()
        self.user_json = [{"id": self.user_model.userId, "name": f"{self.user_model.firstName} {self.user_model.lastName}"}]

    async def create_evaluation_strategy(self, name: str, description: str, strategyFile: UploadFile):
        strategy_id = generate_unique_number()
        strategy_config = None
        try:
            file_bytes = strategyFile.file.read()
            storage_path = get_strategy_storage_path(strategy_id=strategy_id, strategy_name=name)

            if strategyFile.content_type not in ALLOWED_COMPRESSIONS:
                raise Exception("Only ZIP format is supported for strategy upload.")

            with zipfile.ZipFile(io.BytesIO(file_bytes), mode="r") as zip_file:
                for member in zip_file.infolist():
                    with zip_file.open(member) as file_data:
                        abs_path = os.path.join(storage_path, member.filename)
                        self.blob_service.save_file(file_data=file_data, blob_absolute_path=abs_path)

                        if member.filename.endswith(".json") and "config" in member.filename.lower():
                            file_data.seek(0)
                            strategy_config = json.load(file_data)

            if not strategy_config:
                raise Exception("No valid config JSON file found in the ZIP.")

            self.evaluation_dao.save_evaluation_strategy(strategy_id, name, description, strategy_config, self.user_json)
            dcs = self.evaluation_dao.get_evaluation_strategy_by_id(strategy_id)

            return EvaluationResponse(
                strategyId=dcs.id,
                strategyName=dcs.name,
                description=dcs.description,
                strategyConfig=EvalConfig(**dcs.config),
                createdBy=dcs.created_by,
                modifiedBy=dcs.modified_by,
                createdTs=dcs.created_ts,
                modifiedTs=dcs.modified_ts
            )
        except Exception as e:
            logger.error(f"Exception in creating evaluation strategy: {e}", exc_info=True)
            raise Exception(str(e))

    async def update_evaluation_strategy(self, strategy_id: str, name: str, description: str, strategyFile: UploadFile):
        try:
            strategy_config = None
            if strategyFile.content_type not in ALLOWED_COMPRESSIONS:
                raise Exception("Only ZIP format is supported for strategy upload.")

            file_bytes = strategyFile.file.read()
            storage_path = get_strategy_storage_path(strategy_id=strategy_id, strategy_name=name or "strategy")

            with zipfile.ZipFile(io.BytesIO(file_bytes), mode="r") as zip_file:
                for member in zip_file.infolist():
                    with zip_file.open(member) as file_data:
                        abs_path = os.path.join(storage_path, member.filename)
                        self.blob_service.save_file(file_data=file_data, blob_absolute_path=abs_path)

                        if member.filename.endswith(".json") and "config" in member.filename.lower():
                            file_data.seek(0)
                            strategy_config = json.load(file_data)

            self.evaluation_dao.update_evaluation_strategy(strategy_id, name, description, strategy_config, self.user_json)
            dcs = self.evaluation_dao.get_evaluation_strategy_by_id(strategy_id)

            return EvaluationResponse(
                strategyId=dcs.id,
                strategyName=dcs.name,
                description=dcs.description,
                strategyConfig=EvalConfig(**dcs.config),
                createdBy=dcs.created_by,
                modifiedBy=dcs.modified_by,
                createdTs=dcs.created_ts,
                modifiedTs=dcs.modified_ts
            )
        except Exception as e:
            logger.error(f"Exception in updating evaluation strategy: {e}", exc_info=True)
            raise Exception(str(e))

    async def get_evaluation_strategy_by_id(self, strategy_id: str):
        try:
            dcs = self.evaluation_dao.get_evaluation_strategy_by_id(strategy_id)
            if not dcs:
                raise Exception("Evaluation Strategy not found.")

            return EvaluationResponse(
                strategyId=dcs.id,
                strategyName=dcs.name,
                description=dcs.description,
                strategyConfig=EvalConfig(**dcs.config),
                createdBy=dcs.created_by,
                modifiedBy=dcs.modified_by,
                createdTs=dcs.created_ts,
                modifiedTs=dcs.modified_ts
            )
        except Exception as e:
            logger.error(f"Error fetching Evaluation Strategy: {e}")
            raise Exception(str(e))

    async def get_all_evaluation_strategies(self, limit: int, offset: int):
        try:
            items, total = self.evaluation_dao.get_all_evaluation_strategies(limit, offset)
            return {
                "items": [
                    {
                        "strategyId": i.id,
                        "strategyName": i.name,
                        "description": i.description,
                        "strategyConfig": EvalConfig(**i.config),
                        "createdBy": i.created_by,
                        "modifiedBy": i.modified_by,
                        "createdTs": i.created_ts,
                        "modifiedTs": i.modified_ts
                    }
                    for i in items
                ],
                "count": total,
                "limit": limit,
                "offset": offset
            }
        except Exception as e:
            logger.error(f"Error listing Evaluation Strategies: {e}")
            raise Exception(str(e))

    async def delete_evaluation_strategy(self, strategy_id: str):
        try:
            dcs = self.evaluation_dao.get_evaluation_strategy_by_id(strategy_id)
            if not dcs:
                raise Exception("Evaluation Strategy not found.")

            blob_path = get_strategy_storage_path(dcs.id, dcs.name)
            blob_files = self.blob_service.list_files(blob_absolute_path=blob_path)

            for file in blob_files.data:
                self.blob_service.delete_file(blob_absolute_path=file)

            return self.evaluation_dao.delete_evaluation_strategy(strategy_id)
        except Exception as e:
            logger.error(f"Error deleting Evaluation Strategy {strategy_id}: {e}")
            raise Exception(str(e))

    async def download_evaluation_strategy(self, strategy_id: str):
        files = []
        filenames = []
        dcs = self.evaluation_dao.get_evaluation_strategy_by_id(strategy_id)
        if not dcs:
            raise Exception("Evaluation Strategy not found.")

        blob_path = get_strategy_storage_path(dcs.id, dcs.name)
        try:
            response = self.blob_service.list_files(blob_absolute_path=blob_path)
            if not response.data:
                raise Exception("No files found in blob storage.")

            container_name = BlobConfig().BLOB_DOC_CONTAINER
            for file in response.data:
                relative_file = file[len(blob_path):] if file.startswith(blob_path) else file
                blob_location = BlobLocation(container_name=container_name, absolute_path=file)
                output = self.blob_service.load_file(blob_location=blob_location.dict())

                if output.data:
                    files.append(output.data)
                    filenames.append(relative_file)
                else:
                    logger.warning(f"Skipping empty file: {file}")
        except Exception as e:
            logger.error(f"Error downloading evaluation strategy files: {e}")
            raise Exception(str(e))

        return files, filenames



# evaluation_strategy_mgmt_service.py
import logging
import os
import json
import zipfile
import io
from fastapi import UploadFile
from common_svc.logger.log_util import configure_loggers
from common_svc.config.config_store import BlobConfig
from common_svc.storage.storage_config import BlobLocation
from common_svc.storage.blob_service import BlobService
from fts_commons.utils.util import generate_unique_number, get_strategy_storage_path
from fts_commons.schema.user_model import UserModel
from fts_commons.utils.objects import EvaluationResponse, EvalConfig
from evaluation_strategy.dao.evaluation_strategy_mgmt_dao import EvaluationStrategyDAO
from evaluation_strategy.utils.constants import ALLOWED_COMPRESSIONS

configure_loggers()
logger = logging.getLogger(__name__)

class EvaluationStrategyService:
    def __init__(self, user_model: UserModel):
        self.user_model = user_model
        self.evaluation_dao = EvaluationStrategyDAO()
        self.blob_service = BlobService()
        self.user_json = [{"id": self.user_model.userId, "name": f"{self.user_model.firstName} {self.user_model.lastName}"}]

    async def create_evaluation_strategy(self, name: str, description: str, strategyFile: UploadFile):
        strategy_id = generate_unique_number()
        strategy_config = None
        try:
            file_bytes = strategyFile.file.read()
            storage_path = get_strategy_storage_path(strategy_id=strategy_id, strategy_name=name)

            if strategyFile.content_type not in ALLOWED_COMPRESSIONS:
                raise Exception("Only ZIP format is supported for strategy upload.")

            with zipfile.ZipFile(io.BytesIO(file_bytes), mode="r") as zip_file:
                for member in zip_file.infolist():
                    with zip_file.open(member) as file_data:
                        abs_path = os.path.join(storage_path, member.filename)
                        self.blob_service.save_file(file_data=file_data, blob_absolute_path=abs_path)

                        if member.filename.endswith(".json") and "config" in member.filename.lower():
                            file_data.seek(0)
                            strategy_config = json.load(file_data)

            if not strategy_config:
                raise Exception("No valid config JSON file found in the ZIP.")

            self.evaluation_dao.save_evaluation_strategy(strategy_id, name, description, strategy_config, self.user_json)
            strategy = self.evaluation_dao.get_evaluation_strategy_by_id(strategy_id)

            return EvaluationResponse(
                strategyId=strategy.id,
                strategyName=strategy.name,
                description=strategy.description,
                strategyConfig=EvalConfig(**strategy.config),
                createdBy=strategy.created_by,
                modifiedBy=strategy.modified_by,
                createdTs=strategy.created_ts,
                modifiedTs=strategy.modified_ts
            )
        except Exception as e:
            logger.error(f"Exception in creating evaluation strategy: {e}", exc_info=True)
            raise Exception(str(e))

    async def update_evaluation_strategy(self, strategy_id: str, name: str, description: str, strategyFile: UploadFile):
        try:
            strategy_config = None
            if strategyFile.content_type not in ALLOWED_COMPRESSIONS:
                raise Exception("Only ZIP format is supported for strategy upload.")

            file_bytes = strategyFile.file.read()
            storage_path = get_strategy_storage_path(strategy_id=strategy_id, strategy_name=name or "strategy")

            with zipfile.ZipFile(io.BytesIO(file_bytes), mode="r") as zip_file:
                for member in zip_file.infolist():
                    with zip_file.open(member) as file_data:
                        abs_path = os.path.join(storage_path, member.filename)
                        self.blob_service.save_file(file_data=file_data, blob_absolute_path=abs_path)

                        if member.filename.endswith(".json") and "config" in member.filename.lower():
                            file_data.seek(0)
                            strategy_config = json.load(file_data)

            self.evaluation_dao.update_evaluation_strategy(strategy_id, name, description, strategy_config, self.user_json)
            strategy = self.evaluation_dao.get_evaluation_strategy_by_id(strategy_id)

            return EvaluationResponse(
                strategyId=strategy.id,
                strategyName=strategy.name,
                description=strategy.description,
                strategyConfig=EvalConfig(**strategy.config),
                createdBy=strategy.created_by,
                modifiedBy=strategy.modified_by,
                createdTs=strategy.created_ts,
                modifiedTs=strategy.modified_ts
            )
        except Exception as e:
            logger.error(f"Exception in updating evaluation strategy: {e}", exc_info=True)
            raise Exception(str(e))

    async def get_evaluation_strategy_by_id(self, strategy_id: str):
        try:
            strategy = self.evaluation_dao.get_evaluation_strategy_by_id(strategy_id)
            if not strategy:
                raise Exception("Evaluation Strategy not found.")

            return EvaluationResponse(
                strategyId=strategy.id,
                strategyName=strategy.name,
                description=strategy.description,
                strategyConfig=EvalConfig(**strategy.config),
                createdBy=strategy.created_by,
                modifiedBy=strategy.modified_by,
                createdTs=strategy.created_ts,
                modifiedTs=strategy.modified_ts
            )
        except Exception as e:
            logger.error(f"Error fetching Evaluation Strategy: {e}")
            raise Exception(str(e))

    async def get_all_evaluation_strategies(self, limit: int, offset: int):
        try:
            items, total = self.evaluation_dao.get_all_evaluation_strategies(limit, offset)
            return {
                "items": [
                    {
                        "strategyId": i.id,
                        "strategyName": i.name,
                        "description": i.description,
                        "strategyConfig": EvalConfig(**i.config),
                        "createdBy": i.created_by,
                        "modifiedBy": i.modified_by,
                        "createdTs": i.created_ts,
                        "modifiedTs": i.modified_ts
                    }
                    for i in items
                ],
                "count": total,
                "limit": limit,
                "offset": offset
            }
        except Exception as e:
            logger.error(f"Error listing Evaluation Strategies: {e}")
            raise Exception(str(e))

    async def delete_evaluation_strategy(self, strategy_id: str):
        try:
            strategy = self.evaluation_dao.get_evaluation_strategy_by_id(strategy_id)
            if not strategy:
                raise Exception("Evaluation Strategy not found.")

            blob_path = get_strategy_storage_path(strategy.id, strategy.name)
            blob_files = self.blob_service.list_files(blob_absolute_path=blob_path)

            for file in blob_files.data:
                self.blob_service.delete_file(blob_absolute_path=file)

            return self.evaluation_dao.delete_evaluation_strategy(strategy_id)
        except Exception as e:
            logger.error(f"Error deleting Evaluation Strategy {strategy_id}: {e}")
            raise Exception(str(e))

    async def download_evaluation_strategy(self, strategy_id: str):
        files = []
        filenames = []
        strategy = self.evaluation_dao.get_evaluation_strategy_by_id(strategy_id)
        if not strategy:
            raise Exception("Evaluation Strategy not found.")

        blob_path = get_strategy_storage_path(strategy.id, strategy.name)
        try:
            response = self.blob_service.list_files(blob_absolute_path=blob_path)
            if not response.data:
                raise Exception("No files found in blob storage.")

            container_name = BlobConfig().BLOB_DOC_CONTAINER
            for file in response.data:
                relative_file = file[len(blob_path):] if file.startswith(blob_path) else file
                blob_location = BlobLocation(container_name=container_name, absolute_path=file)
                output = self.blob_service.load_file(blob_location=blob_location.dict())

                if output.data:
                    files.append(output.data)
                    filenames.append(relative_file)
                else:
                    logger.warning(f"Skipping empty file: {file}")
        except Exception as e:
            logger.error(f"Error downloading evaluation strategy files: {e}")
            raise Exception(str(e))

        return files, filenames



# evaluation_strategy_mgmt_dao.py
import logging
from common_svc.logger.log_util import configure_loggers
from common_svc.db.base import DBSession
from fts_commons.db.model import EvaluationStrategies
from fts_commons.utils.util import get_current_datetime

configure_loggers()
logger = logging.getLogger(__name__)

class EvaluationStrategyDAO:
    def __init__(self):
        self.created_ts = get_current_datetime()
        self.modified_ts = get_current_datetime()

    def save_evaluation_strategy(self, strategy_id: str, name: str, description: str, config: dict, created_by: str):
        try:
            with DBSession() as db:
                data = EvaluationStrategies(
                    id=strategy_id,
                    name=name,
                    description=description,
                    config=config,
                    created_by=created_by,
                    modified_by=created_by,
                    created_ts=self.created_ts,
                    modified_ts=self.modified_ts
                )
                db.session.add(data)
        except Exception as e:
            logger.error(f"Error saving strategy: {e}", exc_info=True)
            raise Exception(str(e))

    def update_evaluation_strategy(self, strategy_id: str, name: str, description: str, config: dict, modified_by: str):
        try:
            update_config = {}
            if name:
                update_config["name"] = name
            if description:
                update_config["description"] = description
            if config:
                update_config["config"] = config
            if modified_by:
                update_config["modified_by"] = modified_by
            update_config["modified_ts"] = self.modified_ts

            if not update_config:
                logger.error(f"No fields provided to update for strategy ID {strategy_id}")
                raise Exception(f"No fields provided to update for strategy ID {strategy_id}")

            with DBSession() as db:
                is_updated = db.session.query(EvaluationStrategies).filter(EvaluationStrategies.id == strategy_id).update(update_config)
                if not is_updated:
                    logger.error(f"Couldn't update Evaluation Strategy with ID: {strategy_id}")
        except Exception as e:
            logger.error(f"Error updating strategy: {e}", exc_info=True)
            raise Exception(str(e))

    def get_evaluation_strategy_by_id(self, strategy_id: str):
        try:
            with DBSession() as db:
                data = db.session.query(EvaluationStrategies).filter(EvaluationStrategies.id == strategy_id).first()
                if data is None:
                    logger.error(f"No Evaluation Strategy found with ID {strategy_id}")
                    raise Exception(f"No Evaluation Strategy found with ID {strategy_id}")
                return data
        except Exception as e:
            logger.error(f"Error retrieving strategy by ID {strategy_id}: {e}")
            raise Exception(str(e))

    def get_all_evaluation_strategies(self, limit: int, offset: int):
        try:
            with DBSession() as db:
                query = db.session.query(EvaluationStrategies)
                total_count = query.count()
                strategies = query.offset(offset).limit(limit).all()
                return strategies, total_count
        except Exception as e:
            logger.error(f"Error fetching Evaluation Strategy list: {e}")
            raise Exception(str(e))

    def delete_evaluation_strategy(self, strategy_id: str):
        try:
            with DBSession() as db:
                deleted = db.session.query(EvaluationStrategies).filter(EvaluationStrategies.id == strategy_id).delete(synchronize_session=False)
                if not deleted:
                    logger.error(f"Couldn't delete Evaluation Strategy with ID {strategy_id}")
                    return {"message": f"Couldn't delete Evaluation Strategy with ID {strategy_id}"}
                return {"message": f"Evaluation Strategy {strategy_id} deleted successfully."}
        except Exception as e:
            logger.error(f"Error deleting Evaluation Strategy with ID {strategy_id}: {e}")
            raise Exception(str(e))




# flow.dag.yaml for Promptflow Evaluation Strategy
name: evaluation-strategy-flow
description: Run evaluation using LLM-as-Judge component
entry: judge_component.evaluate
inputs:
  input_file: file
outputs:
  result: json



# flow.dag.yaml for Promptflow Evaluation Strategy
name: evaluation-strategy-flow
description: Run evaluation using LLM-as-Judge component
entry: judge_component.evaluate
inputs:
  input_file: file
outputs:
  result: json

# judge_component.py for Promptflow
import json
import pandas as pd
from judge.llm_as_judge import compute_sop_accuracy

def evaluate(input_file: str) -> dict:
    with open(input_file, "r") as f:
        records = json.load(f)

    df = pd.DataFrame(records)
    df_result = compute_sop_accuracy(
        df,
        qstn_col="Question",
        col_generated_ans="Generated_Answer",
        gndth_col="Answer"
    )

    return {"result": df_result.to_dict(orient="records")}



# flow.dag.yaml for Promptflow Evaluation Strategy
name: evaluation-strategy-flow
description: Run evaluation using LLM-as-Judge component
entry: judge_component.evaluate
inputs:
  input_file: file
outputs:
  result: json

# judge_component.py for Promptflow
import json
import pandas as pd
from judge.llm_as_judge import compute_sop_accuracy

def evaluate(input_file: str) -> dict:
    with open(input_file, "r") as f:
        records = json.load(f)

    df = pd.DataFrame(records)
    df_result = compute_sop_accuracy(
        df,
        qstn_col="Question",
        col_generated_ans="Generated_Answer",
        gndth_col="Answer"
    )

    return {"result": df_result.to_dict(orient="records")}

# requirements.txt
pandas
promptflow
openai

# sample_input.jsonl
[
  {
    "Question": "What is the capital of France?",
    "Generated_Answer": "Paris",
    "Answer": "Paris"
  },
  {
    "Question": "What is the currency of Japan?",
    "Generated_Answer": "Yen",
    "Answer": "Yen"
  }
]

# run_evaluation.py (test script)
import sys
import json
import pandas as pd
from judge_component import evaluate

if __name__ == "__main__":
    input_file = sys.argv[1] if len(sys.argv) > 1 else "sample_input.jsonl"
    result = evaluate(input_file)
    print(json.dumps(result, indent=2))

# POST API logic to trigger evaluation (add to evaluation_strategy_mgmt_api.py)
@es_apis.post("/evaluation-strategy/{esId}/run-evaluation")
async def run_evaluation_strategy(esId: str, userModel: UserModel = Depends(get_login_info)):
    try:
        files, filenames = await EvaluationStrategyService(userModel).download_evaluation_strategy(esId)
        input_file = None
        for name, content in zip(filenames, files):
            if name.endswith(".json") and "input" in name:
                with open(f"/tmp/{name}", "wb") as f:
                    f.write(content)
                    input_file = f.name
        if not input_file:
            raise HTTPException(status_code=404, detail="No input file found in ZIP")

        from judge_component import evaluate
        result = evaluate(input_file)
        return {"success": True, "result": result["result"]}
    except Exception as e:
        error = Errors.E407.format(e=str(e), esId=esId)
        logger.error(error, exc_info=True)
        return JsonResponse(success=False, error=error).dict()




